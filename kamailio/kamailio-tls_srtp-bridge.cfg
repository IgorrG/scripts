#!KAMAILIO
#
# Kamailio (OpenSER) SIP Server v5.3
# Kamailio as SIP Edge Router
# March 2020

# Need help?
# * Free/Official: 
#	-	Documentation: https://www.kamailio.org/w/documentation/
#	-	Wiki: https://www.kamailio.org/wiki/
# 	-	Modules: https://www.kamailio.org/docs/modules/stable/
#	-	IRC: irc.freenode.net #kamailio
#	-	Mailing Lists: https://www.kamailio.org/w/mailing-lists/
# * Commercial:
#	-	LOD: https://lod.com fred@lod.com (more contact options at https://qxork.com)
#	-	Business Directory: https://www.kamailio.org/w/business-directory/

####### Define Substitutions #######
#!substdef "/PRIVATEIP/192.168.86.34/"
#!substdef "/PUBLICIP/1.2.3.4/"
#!substdef "/PUBDOMAIN/mydomain.com/"
#!substdef "/PBXIP/192.168.86.220/"
#!substdef "/APIBANKEY/1234567890abcdefgh/"

####### Define Code Blocks #########
#	define WITH_DEBUG
#!define WITH_ANTIFLOOD
#	define WITH_APIBAN
#!define WITH_RTPENGINE
#!define WITH_NAT
#!define WITH_TLS
#	define WITH_SIPDEBUG

####### Defined Values #########
# - flags
#   FLT_ - per transaction (message) flags
#	FLB_ - per branch flags
#!define FLT_NATS 5
#!define FLB_NATB 6
#!define FLB_NATSIPPING 7

####### Global Parameters #########
### LOG Levels: 3=DBG, 2=INFO, 1=NOTICE, 0=WARN, -1=ERR
#!ifdef WITH_DEBUG
debug=4
log_stderror=yes
#!else
debug=2
log_stderror=no
#!endif

memdbg=5
memlog=5
pv_buffer_size=65536
pv_cache_limit=65536
log_facility=LOG_LOCAL0
log_prefix="{$mt $proto $hdr(CSeq) $ci} "
children=8
#!ifdef WITH_TLS
enable_tls=yes
tcp_connection_lifetime=3605
#!else
disable_tcp=yes
disable_tls=yes
#!endif
dns=no
dns_cache_init=off
dns_srv_lb=no
dns_try_naptr=no
maxbuffer=65536
max_while_loops=250
rev_dns=no
use_dns_cache=no
auto_aliases=no
mhomed=0
listen=udp:PRIVATEIP:5060
#!ifdef WITH_TLS
listen=tls:PRIVATEIP:5061 advertise PUBLICIP:5061
alias=PUBDOMAIN
#!endif
port=5060
#!ifdef WITH_SIPDEBUG
onsend_route_reply=yes
#!endif
server_header="Server: kamailio 5.3"

####### Modules Section ########
loadmodule "jsonrpcs.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "outbound.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "rtimer.so"
loadmodule "ipops.so"
loadmodule "uac.so"
loadmodule "json.so"
loadmodule "http_client.so"
loadmodule "jansson.so"
loadmodule "htable.so"
loadmodule "textopsx.so"

#!ifdef WITH_RTPENGINE
loadmodule "rtpengine.so"
loadmodule "sdpops.so"
#!endif

loadmodule "nathelper.so"

#!ifdef WITH_TLS
loadmodule "tls.so"
#!endif

#!ifdef WITH_ANTIFLOOD
loadmodule "pike.so"
#!endif

#!ifdef WITH_XMLRPC
loadmodule "xmlrpc.so"
#!endif

#!ifdef WITH_DEBUG
loadmodule "debugger.so"
#!endif

# ----------------- setting module-specific parameters ---------------
# ----- jsonrpcs params -----
modparam("jsonrpcs", "pretty_format", 1)

# ----- ctl params -----
modparam("ctl", "binrpc", "unix:/var/run/kamailio/kamailio_ctl")
modparam("ctl", "binrpc", "tcp:localhost:2046")

# ----- tm params -----
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", 30000)
modparam("tm", "fr_inv_timer", 120000)
modparam("tm", "max_inv_lifetime", 180000)
modparam("tm", "noisy_ctimer", 1)
modparam("tm", "faked_reply_prio", 2000)
modparam("tm", "restart_fr_on_each_reply", 1)
modparam("tm", "auto_inv_100", 1)
modparam("tm", "auto_inv_100_reason", "Kamailio trying")
modparam("tm", "cancel_b_method", 1)

# ----- rr params -----
modparam("rr", "enable_full_lr", 1)
modparam("rr", "append_fromtag", 1)

# ----- rtimer params -----
#!ifdef WITH_APIBAN
modparam("rtimer", "timer", "name=twt;interval=300;mode=1;")
modparam("rtimer", "exec", "timer=twt;route=APIBAN")
modparam("htable", "htable", "apiban=>size=11;")
modparam("htable", "htable", "apibanctl=>size=1;initval=0;")
#!endif

#!ifdef WITH_NAT
# ----- nathelper params -----
modparam("nathelper", "received_avp", "$avp(RECEIVED)")
modparam("nathelper", "nortpproxy_str", "a=sdpmangled:yes\r\n")
#!endif

#!ifdef WITH_TLS
# ----- tls params -----
modparam("tls", "config", "/usr/local/etc/kamailio/tls.cfg")
#!endif

#!ifdef WITH_RTPENGINE
# ----- rtpproxy params -----
modparam("rtpengine", "rtpengine_sock", "udp:127.0.0.1:7722")
#!endif

#!ifdef WITH_ANTIFLOOD
# ----- pike params -----
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)

# ----- htable params -----
/* ip ban htable with autoexpire after 5 minutes */
modparam("htable", "htable", "ipban=>size=8;autoexpire=14400")
#!endif

#!ifdef WITH_XMLRPC
# ----- xmlrpc params -----
modparam("xmlrpc", "route", "XMLRPC");
modparam("xmlrpc", "url_match", "^/RPC")
#!endif

#!ifdef WITH_DEBUG
# ----- debugger params -----
modparam("debugger", "cfgtrace", 1)
modparam("debugger", "log_level_name", "exec")
#!endif

# do not follow redirects
modparam("http_client", "httpredirect", 0)
modparam("http_client", "connection_timeout", 4)
modparam("http_client", "verify_peer", 0)
modparam("http_client", "verify_host", 0)
modparam("http_client", "keep_connections", 1)

####### Routing Logic ########
request_route {
#!ifdef WITH_SIPDEBUG
	xlog("L_INFO","[MAIN] SIP DEBUG: \n$mb\n");
#!endif

	# per request initial checks
	route(REQINIT);

	# NAT detection
	route(NATDETECT);

	# CANCEL processing
	if (is_method("CANCEL")) {
		if (t_check_trans()) {
			route(RELAY);
		}
		exit;
	}

	# handle retransmissions
	if (!is_method("ACK")) {
		if(t_precheck_trans()) {
			t_check_trans();
			exit;
		}
		t_check_trans();
	}

	route(WITHINDLG);

	remove_hf("Route");
	if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
		xlog("L_INFO","[MAIN]: record route\n");
		record_route();
	}

	if ($rU==$null && !is_method("REGISTER")) {
		xlog("L_INFO","[MAIN]: no username in ruri and not register - send 484\n");
		sl_send_reply("484","Address Incomplete M1");
		exit;
	}
	
	route(CHECKREALM);

	route(RELAY);
	exit;
}

# Wrapper for relaying requests
route[RELAY] {
	if(is_rfc1918("$rd")) {
		xlog("L_INFO", "[RELAY] $rd is nat\n");
		handle_ruri_alias();
		switch ($rc) {
		case -1:
			xlog("L_ERR", "[RELAY] Failed to handle alias of R-URI $ru\n");
			send_reply("400", "Bad request");
			exit;
		case 1:
			xlog("L_INFO", "[RELAY] case 1 Routing in-dialog $rm from $fu to $du\n");
			break;
		case 2:
			xlog("L_INFO", "[RELAY] case 2 Routing in-dialog $rm from $fu to $ru\n");
			break;
		};
	};

	if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
		if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
	}

	if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
		if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
	}

	if (is_method("INVITE")) {
		if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
	}

	xlog("L_INFO", "[RELAY] Relaying $ru\n");
	if (!t_relay()) {
		sl_reply_error();
	}

	exit;
}

# Per SIP request initial checks
route[REQINIT] {
#!ifdef WITH_ANTIFLOOD
	if(src_ip!=myself && $si!="PBXIP") {
		if($sht(ipban=>$si)!=$null) {
			xdbg("request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
			exit;
		}

		if($sht(apiban=>$si)!=$null) {
			xdbg("request from apiban.org blocked IP - $rm from $fu (IP:$si:$sp)\n");
			exit;
		}

		if (!pike_check_req()) {
			xlog("L_ALERT","ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
			$sht(ipban=>$si) = 1;
			exit;
		}
	}
#!endif

	if($ua =~ "friendly-scanner|sipcli|VaxSIPUserAgent") {
		xlog("L_INFO","[R-REQINIT]: script kiddies from IP:$si:$sp - dropping and blocking\n");
		route(BLOCKIP);
		exit;
	}

	if($au =~ "(\=)|(\-\-)|(')|(\#)|(\%27)|(\%24)" and $au != $null) {
		xlog("L_INFO","[R-REQINIT]: sql injection from IP:$si:$sp - dropping\n");
		route(BLOCKIP);
		exit;
	}

	if (!mf_process_maxfwd_header("10")) {
		xlog("L_INFO","[R-REQINIT]: too many hops\n");
		sl_send_reply("483","R1 Too Many Hops");
		exit;
	}

	if(is_method("OPTIONS")){
		if(uri==myself) {
			sl_send_reply("200","Keep on Keeping on");
			exit;
		} else {
			xlog("L_INFO","[R-REQINIT]: Ignoring options from IP:$si:$sp\n");
			exit;
		}
	}

	if(!sanity_check("17895", "7")) {
		xlog("L_INFO","[R-REQINIT]: Malformed SIP message from $si:$sp\n");
		exit;
	}
}

route[WITHINDLG] {
	if (!has_totag()) return;

	if (loose_route()) {
		xlog("L_INFO","[R-WITHINDLG] relaying loose route\n");
		route(DLGURI);
		if (is_method("BYE")) {
			xlog("L_INFO","[R-WITHINDLG] received BYE from $si\n");
		} else if ( is_method("NOTIFY") ) {
			record_route();
		}
		route(RELAY);
		exit;
	}

	if ( is_method("ACK") ) {
		if ( t_check_trans() ) {
			route(RELAY);
			exit;
		} else {
			exit;
		}
	}

	sl_send_reply("404","Not here WD1");
	exit;
}

route[CHECKREALM] {
	if ($si!="PBXIP") {
		xlog("L_INFO","[R-CKR] not from media server\n");
		$du = "sip:PBXIP";
		rewritehostporttrans("PBXIP:5060");

		xlog("L_INFO","[R-CKR] updating contact to non TLS \n");
		$var(user) = $(ct{tobody.user});
		$var(host) = $si + ":" + $sp;
		msg_apply_changes();
		remove_hf("Contact");
		msg_apply_changes();
		insert_hf("Contact: <sip:$var(user)@PRIVATEIP;registering_acc=$rd;ohost=$var(host);omod=kamabr>\r\n", "Call-ID");
		msg_apply_changes();
		
		xlog("L_INFO","[R-CKR] $rd known, sending to $du \n");
		return;
	}

	if ($(ru{uri.param,omod}) == "kamabr") {
		xlog("L_INFO","[R-CKR] omod exists in $ru \n");
		$var(host) = $(ru{uri.param,ohost});
		$var(furi) = "sip:" + $fU + "@" + $(ru{uri.param,registering_acc});
		$var(turi) = "sip:" + $(ru{uri.user}) + "@" + $(ru{uri.param,registering_acc});
		$rd = $(ru{uri.param,registering_acc});
		$du = "sips:" + $(ru{uri.user}) + "@" + $var(host);
		uac_replace_to("$var(turi)");
		uac_replace_from("$var(furi)");
		xlog("L_INFO","[R-CKR] to, from, rd, du modified. ru now $ru \n");
	}

	xlog("L_INFO","[R-CKR] relaying from internal media server to $rd\n");
	return;
}

route[NATDETECT] {
#!ifdef WITH_NAT
	force_rport();
	if (nat_uac_test("19")) {
		if (is_method("REGISTER")) {
			xlog("L_INFO","[R-NATDETECT] fix natted register\n");
			msg_apply_changes();
			fix_nated_register();
			msg_apply_changes();
			if (nat_uac_test("1")) {
				xlog("L_INFO","[R-NATDETECT] uac 1 set contact alias\n");
				msg_apply_changes();
				set_contact_alias();
				msg_apply_changes();
			}
		} else {
			if(is_first_hop()) {
				xlog("L_INFO","[R-NATDETECT] non register set contact alias\n");
				msg_apply_changes();
				set_contact_alias();
				msg_apply_changes();
			}
		}

		setflag(FLT_NATS);
	}
 
#!endif
	return;
}

route[DLGURI] {
#!ifdef WITH_NAT
	if(!isdsturiset()) {
		xlog("L_INFO","[R-DLGURI] not isdsturiset - handle alias\n");
		handle_ruri_alias();
		return;
	} else if (is_rfc1918("$rd")) {
		# domain in r-uri is private address
		xlog("L_INFO","[R-DLGURI] $rd is rfc1918 - handle alias\n");
		handle_ruri_alias();
		return;
	}
#!endif
	return;
}

route[NATMANAGE] {
#!ifdef WITH_NAT
	if (is_request()) {
		if(has_totag()) {
			if(check_route_param("nat=yes")) {
				xlog("L_INFO","[R-NATMANAGE] nat=yes present. set flb_natb\n");
				setbflag(FLB_NATB);
			}
		}
	}

	if (is_reply()) {
		if(nat_uac_test("1")){
			xlog("L_INFO","[R-NATMANAGE] contact is nat. set flb_natb\n");
			setbflag(FLB_NATB);
		}
	}

#!ifdef WITH_RTPENGINE
	if(has_totag()) {
		if((is_method("INVITE|UPDATE|ACK") && sdp_content()) || is_method("BYE")) {
			if(is_method("BYE")) {
 				rtpengine_delete();
			} else if(is_method("INVITE|UPDATE")) {
				xlog("L_INFO", "[R-NATMANAGE] -> Engaging RTPEngine for in-dialog request\n");
				if(isflagset(FLT_NATS)) {
					if (proto==TLS && !($dP=="UDP")) {
						rtpengine_offer("RTP/AVP replace-origin replace-session-connection SIP-source-address ICE=remove  direction=internal direction=external");
					} else {
						rtpengine_offer("RTP/SAVP replace-origin replace-session-connection SIP-source-address ICE=remove direction=external direction=internal");
					}
				} else {
					if (proto==TLS && !($dP=="UDP")) {
						rtpengine_offer("RTP/AVP replace-origin replace-session-connection ICE=remove direction=internal direction=external");
					} else {
						rtpengine_offer("RTP/SAVP replace-origin replace-session-connection ICE=remove direction=external direction=internal");
					}
				}
			} else if(is_method("ACK")) {
				rtpengine_answer();
			}
		}

		t_on_reply("MANAGE_REPLY");
	} else {
		if (is_method("INVITE")) {
			if (has_body("application/sdp")) {
				if(isflagset(FLT_NATS)) {
					if (proto==TLS && $dP=="UDP") {
						rtpengine_offer("RTP/AVP replace-origin replace-session-connection SIP-source-address ICE=remove direction=internal direction=external");
					} else {
						rtpengine_offer("RTP/SAVP replace-origin replace-session-connection SIP-source-address ICE=remove direction=external direction=internal");
					}
				} else {
					if (proto==TLS && $dP=="UDP") {
						rtpengine_offer("RTP/AVP replace-origin replace-session-connection ICE=remove direction=internal direction=external");
					} else {
						rtpengine_offer("RTP/SAVP replace-origin replace-session-connection ICE=remove direction=external direction=internal");
					}
				}
			}
		}
	}
#!endif

	if (is_request()) {
		if (!has_totag()) {
			if(t_is_branch_route()) {
				xlog("L_INFO","[R-NATMANAGE] add nat=yes\n");
				add_rr_param(";nat=yes");
			}
		}
	}

	if (is_reply()) {
		if(isbflagset(FLB_NATB)) {
			if(is_first_hop())
				xlog("L_INFO","[R-NATMANAGE] first hop bflagset set contact alias\n");
				set_contact_alias();
		}
	}

	if (is_rfc1918("$rd")) {
		xlog("L_INFO","[R-NATMANAGE] $rd is rfc1918 - handle alias\n");
		handle_ruri_alias();
		return;
	}

	if(isbflagset(FLB_NATB)) {
		if (is_request()) {
			if(has_totag()) {
				set_forward_no_connect();
			}
		}
	}
#!endif

	return;
}

route[BLOCKIP] {
	if(src_ip!=myself) {
		xlog("L_INFO","[R-BLOCKIP:$ci]: blocking $rm from $fu (IP:$si:$sp)\n");
		$sht(ipban=>$si) = 1;
	}

	return;
}

branch_route[MANAGE_BRANCH] {
	xdbg("new branch [$T_branch_idx] to $ru\n");
	route(NATMANAGE);
}

# Manage incoming replies
onreply_route[MANAGE_REPLY] {
	xdbg("incoming reply\n");
	xlog("L_INFO","[R-M-REPLY] handling reply $rs\n");
	if(status=~"[12][0-9][0-9]") {
		route(NATMANAGE);
	}
}

# Manage failure routing cases
failure_route[MANAGE_FAILURE] {
	xlog("L_INFO","[R-M-FAILURE] handling failure $rs\n");
	route(NATMANAGE);
	if (t_is_canceled()) exit;
}

route[APIBAN] {
#!ifdef WITH_APIBAN
	$var(KEY) = "APIBANKEY";

	if($sht(apibanctl=>ID) == 0) {
		$var(apiget) = "https://apiban.org/api/" + $var(KEY) + "/banned";
	} else {
		$var(apiget) = "https://apiban.org/api/" + $var(KEY) + "/banned/" + $sht(apibanctl=>ID);
	}

	xlog("L_INFO","API SEND: $var(apiget)\n");
	http_client_query("$var(apiget)", "$var(banned)");

	if($rc!=200) {
		xlog("L_INFO","API ERR: No 200 Received. $var(banned)\n");
		exit;
	} else {
		xlog("L_INFO","API: $var(banned)\n");
	}

	$var(count) = 0;
	jansson_array_size("ipaddress", $var(banned), "$var(size)");
	while($var(count) < $var(size)) {
		jansson_get("ipaddress[$var(count)]", $var(banned), "$var(v)");
		$sht(apiban=>$var(v)) = 1;
		xlog("L_INFO","API: ipaddress[$var(count)] == $var(v)\n");

		$var(count) = $var(count) + 1;
	}

	jansson_get("ID", $var(banned), "$var(w)");
	xlog("L_INFO","ID: $var(w)\n");
	$sht(apibanctl=>ID) = $var(w);
#!endif
	xdbg("apiban complete\n");
}

event_route[htable:mod-init] {
	route(APIBAN);
}

#!ifdef WITH_SIPDEBUG
onsend_route {
	xlog("L_INFO","[ONSEND_ROUTE] SIP DEBUG: \n$snd(buf)\n");
}
#!endif
